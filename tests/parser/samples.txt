def summ(x, y):
    r = x + y
    return r
===
F summ(x, y)
   V r = x + y
   R r


message : str
pos : int = 0
type_args : List[str]
t : Tuple[str, int]
===
String message
Int pos = 0
[String] type_args
(String, Int) t


# Test for some class based on class Exception
class MyException(Exception):
    message : str
    line : int
    column : int
    pos : int

    def __init__(self, message, line, column, pos):
        self.message = message
        self.line = line
        self.column = column
        self.pos = pos
===
T MyException
   String message
   Int line
   Int column
   Int pos

   F (message, line, column, pos)
      .message = message
      .line = line
      .column = column
      .pos = pos


# Test for some class which is not based on other one
class Person:
    name : str
    age : int

    def __init__(name, age):
        self.name = name
        self.age  = age
===
T Person
   String name
   Int age

   F (name, age)
      .name = name
      .age = age


# Test for some class based on non Exception class
class Shape:
    position : Tuple[int, int]

class Circle(Shape):
    radious : int
===
T Shape
   (Int, Int) position

T Circle(Shape)
   Int radious


class Converter:
    def to_html(self, instr):
        def get_newline_chars():
            newline_chars : List[int] = []
            i = 0
            while i < len(instr):
                if instr[i] == "\r" or (instr[i] == "\n" and instr[i - 1:i] != "\r"):
                    newline_chars += [i]
                i += 1
            return newline_chars
===
T Converter
   F to_html(instr)
      F get_newline_chars()
         [Int] newline_chars
         V i = 0
         L i < @instr.len
            I @instr[i] == "\r" | (@instr[i] == "\n" & @instr[i - 1 .< i] != "\r")
               newline_chars [+]= i
            i++
         R newline_chars


---
===
F to_html(instr)
   F get_newline_chars()
      V i = 0
      L i < @instr.len
         I @instr[i] == "\r" | (@instr[i] == "\n" & @instr[i - 1 .< i] != "\r")
            R [+]= i
         i++


arr : List[int] = []
arr += [1, 2]
===
[Int] arr
arr [+]= [1, 2]


(1,)
===
(1,)


indentation_levels : List[int]
prev_indentation_level = indentation_levels[-1] if len(indentation_levels) else 0
if len(indentation_levels):
    prev_indentation_level = indentation_levels[-1]
else:
    prev_indentation_level = 0
def f(): # test for error when instead of `s = self \n while not s.is_function:` was `s = self.parent \n while s is not None and not s.is_function:`
    prev_indentation_level = 0
class ASTNodeWithChildren:
    def children_to_str_detect_single_stmt(self, indent, r):
        if len(self.children) > 1 or len(self.children) == 0:
            return self.children_to_str(indent, r)
[1, 2]
===
[Int] indentation_levels
V prev_indentation_level = I !indentation_levels.empty {indentation_levels.last} E 0
I !indentation_levels.empty
   prev_indentation_level = indentation_levels.last
E
   prev_indentation_level = 0
F f()
   V prev_indentation_level = 0
T ASTNodeWithChildren
   F children_to_str_detect_single_stmt(indent, r)
      I .children.len > 1 | .children.empty
         R .children_to_str(indent, r)
[1, 2]


def sgn(x):
    if x < 0:
        return -1
    elif x > 0:
        return 1
    else:
        return 0
===
F sgn(x)
   I x < 0
      R -1
   E I x > 0
      R 1
   E
      R 0


---
key : str
if token.category in (Token.Category.NUMERIC_LITERAL, Token.Category.STRING_LITERAL):
    key = '(literal)'
elif token.category == Token.Category.NAME:
    key = '(name)'
elif token.category == Token.Category.CONSTANT:
    key = '(constant)'
elif token.category in (Token.Category.STATEMENT_SEPARATOR, Token.Category.DEDENT):
    key = ';'
else:
    key = token.value(source)
===
String key = S token.category
   NUMERIC_LITERAL, STRING_LITERAL
      ‘(literal)’
   NAME
      ‘(name)’
   CONSTANT
      ‘(constant)’
   STATEMENT_SEPARATOR, DEDENT
      ‘;’
   E
      token.value(source)


def exit_with_error(message, pos):
    pass
def find_ending_sq_bracket(str, i, start = 0):
    starti = i
    assert(str[i] == "[") # ]
    nesting_level = 0
    while True:
        ch = str[i]
        if ch == "[":
            nesting_level += 1
        elif ch == "]":
            nesting_level -= 1
            if nesting_level == 0:
                return i
        i += 1
        if i == len(str):
            exit_with_error('Unended comment started', start + starti)
===
F exit_with_error(message, pos)
{
}
F find_ending_sq_bracket(str, =i, start = 0)
   V starti = i
   assert(str[i] == ‘[’)
   V nesting_level = 0
   L
      S str[i]
         ‘[’
            nesting_level++
         ‘]’
            I --nesting_level == 0
               R i
      i++
      I i == str.len
         exit_with_error(‘Unended comment started’, start + starti)


---
// balancing ]


s : str
s[-2]
i = 0
s[-1-i]
s[:-1]
s[1:]
#s[:1:] # this does not make any sense — please write `s[:1]` instead
s[:2]
s[1:2]
s[::2]
s[1::2]
s[3:10:2]
s[:10:2]
#s[3:10:] # this does not make any sense — please write `s[3:10]` instead
===
String s
s[(len)-2]
V i = 0
s[(len)-1 - i]
s[0 .< (len)-1]
s[1..]
s[0.<2]
s[1.<2]
s[(0..).step(2)]
s[(1..).step(2)]
s[(3.<10).step(2)]
s[(0.<10).step(2)]


class ASTAssignmentWithTypeHint:
    def to_str(self, indent):
        return super().to_str(indent)[:-1] + ' = ' + self.expression.to_str() + "\n"
===
T ASTAssignmentWithTypeHint
   F to_str(indent)
      R T.base.to_str(indent)[0 .< (len)-1]‘ = ’(.expression.to_str())"\n"


def html_escapeq(str):
    return str.replace('&', '&amp;').replace('"', '&quot;')
link = 'http://...'
tag : str = '<a href="' + link + '"' # while type inference is not supported, type hint is necessary to convert from `+=` to `‘’=`
tag += html_escapeq()
ins = ''
pre = '<pre ' + ins
print(pre + html_escapeq(''))
class TableCell:
    attrs : str
    def __init__(self, attrs):
        self.attrs = attrs
table : List[List[TableCell]] = []
table[0][0].attrs += ' colspan="'+str(1)+'"'
table[0][0].attrs += ' '
===
F html_escapeq(str)
   R str.replace(‘&’, ‘&amp;’).replace(‘"’, ‘&quot;’)
V link = ‘http://...’
String tag = ‘<a href="’link‘"’
tag ‘’= html_escapeq()
V ins = ‘’
V pre = ‘<pre ’ins
print(pre‘’html_escapeq(‘’))
T TableCell
   String attrs
   F (attrs)
      .attrs = attrs
[[TableCell]] table
table[0][0].attrs ‘’= ‘ colspan="’String(1)‘"’
table[0][0].attrs ‘’= ‘ ’


str1 = '1'
str2 = '2'
# s = str1 + str2 # this is rarely needed {and, for example, `if c1 + c2 == "/\\"` can be rewritten as `if (c1, c2) == ('/', "\\")`, which is more efficient}, so write this:
s = str1 + '' + str2
===
V str1 = ‘1’
V str2 = ‘2’
V s = str1‘’str2


a : bool
b : bool
c : bool
if (a and b) or c:
    if a and (b or c):
        return
class ASTIf:
    pass
if (self.parent is None and isinstance(self.ast_parent, ASTIf)) or (self.parent is not None and self.parent.symbol.id == 'if'):
    return
===
Bool a
Bool b
Bool c
I (a & b) | c
   I a & (b | c)
      R
T ASTIf
{
}
I (.parent == N & T(.ast_parent) >= ASTIf) | (.parent != N & .parent.symbol.id == ‘if’)
   R


l = lambda: None
l = lambda x: x[0]
l = lambda self: self # `self` here should not be replaced with ``
l = lambda x, y, reverse = False: y < x if reverse else x < y
if True:
    c = 1
    l = lambda x: x < c
c = 1
l = lambda x: x < c
===
V l = () -> N
l = x -> x[0]
l = self -> self
l = (x, y, reverse = 0B) -> I reverse {y < x} E x < y
I 1B
   V c = 1
   l = x -> x < @c
V c = 1
l = x -> x < :c


class Object:
    pass

def f():
    pass
===
T Object
{
}

F f()
{
}


1 in 2
1 not in 2
===
1 C 2
1 !C 2


a : str
b : str
a is b
a is not b
===
String a
String b
&a == &b
&a != &b


source : str
def prev_char():
   return "\0"
tag = {'*':'b', '_':'u', '-':'s', '~':'i'}[prev_char()]
return {'None': 'N', 'False': '0B', 'True': '1B'}[self.token.value(source)]
python_types_to_11l = {'int':'Int', 'str':'String', 'List':'Array', 'Tuple':'Tuple'}
return self.children[0].to_str() + ' ' + {'and':'&', 'or':'|', 'in':'C'}.get(self.symbol.id, 'symbol-' + self.symbol.id) + ' ' + self.children[1].to_str()
===
String source
F prev_char()
   R "\0"
V tag = S prev_char() {‘*’ {‘b’}; ‘_’ {‘u’}; ‘-’ {‘s’}; ‘~’ {‘i’}}
R S .token.value(source) {‘None’ {‘N’}; ‘False’ {‘0B’}; ‘True’ {‘1B’}}
V python_types_to_11l = [‘int’ = ‘Int’, ‘str’ = ‘String’, ‘List’ = ‘Array’, ‘Tuple’ = ‘Tuple’]
R .children[0].to_str()‘ ’(S .symbol.id {‘and’ {‘&’}; ‘or’ {‘|’}; ‘in’ {‘C’} E ‘symbol-’(.symbol.id)})‘ ’(.children[1].to_str())


x : bool
y : bool
ins : str
return not x == y # operator `==` in Python has higher precedence than `not` (in 11l it's precedence is lower)
return not x or y # operators `or` and `and` in Python have lower precedence than `not`
return not "\n" in ins
return not x
return not (x)
===
Bool x
Bool y
String ins
R !(x == y)
R !x | y
R !("\n" C ins)
R !x
R !(x)


class Converter:
    def to_html(self, instr, outfile = None):
        i = 0
        writepos = 0
        def write_to_pos(pos, npos):
            nonlocal writepos
            outfile.write(instr[writepos:pos])
            writepos = npos
            gpos = 1
            global gpos
            gpos = 2
        def write_to_i(add_str, skip_chars = 1):
            def write():
                write_to_pos(i, i+skip_chars)
            write()
            outfile.write(add_str)
===
T Converter
   F to_html(instr, outfile = N)
      V i = 0
      V writepos = 0
      F write_to_pos(pos, npos)
         @outfile.write(@instr[@writepos .< pos])
         @writepos = npos
         V gpos = 1
         :gpos = 2
      F write_to_i(add_str, skip_chars = 1)
         F write()
            @@write_to_pos(@@i, @@i + @skip_chars)
         write()
         @outfile.write(add_str)


token = None
err_token = None
err_token if err_token is not None else token
===
V token = N
V err_token = N
err_token ? token


ch : str
if '0' <= ch <= '9':
    pass
if not '0' <= ch <= '9':
    pass
if '0' <= ch < '9':
    if '0' < ch <= '9':
        if '0' < ch < '9':
            pass
===
String ch
I ch C ‘0’..‘9’
{
}
I !(ch C ‘0’..‘9’)
{
}
I ch C ‘0’.<‘9’
   I ch C ‘0’<.‘9’
      I ch C ‘0’<.<‘9’
      {
      }


12_345
0o123_45
-0x0000FFFF
0xF
0xFF
0xFFF
0xFFFF
0x00FFFF
0b10101010
-0b10101010
1.234_5e20
===
12'345
123'45o
-0000'FFFF
0'F
F'F
0F'FF
FF'FF
0000'FFFF
10101010b
-10101010b
1.234'5e20


n = '123'
number_with_separators = ''
j = len(n)
while j > 4:
    number_with_separators = "'" + n[j-4:j] + number_with_separators
    j -= 4
===
V n = ‘123’
V number_with_separators = ‘’
V j = n.len
L j > 4
   number_with_separators = ‘'’n[j - 4 .< j]‘’number_with_separators
   j -= 4


def roman(n):
    pass

if __name__ == '__main__':
    assert roman(6) == 'VI', '6'
    print("Earn cool rewards by using the 'Check' button!")
===
F roman(n)
{
}

:start:
assert(roman(6) == ‘VI’, ‘6’)
print(‘Earn cool rewards by using the 'Check' button!’)



arr : List[str] = []
', '.join(arr)
===
[String] arr
arr.join(‘, ’)


indent = 0
# [https://sourceforge.net/u/t-a-v/11l/python_to_11l/ci/0f3fd6937ae538434f145c81815de8c3ced4dadc/tree/parse.py#l189 <- https://bitbucket.org/11l-lang/python_to_11l/src/0f3fd6937ae538434f145c81815de8c3ced4dadc/parse.py#lines-189]:
r = self.newlines() + ' ' * (indent*3) + 'F ' + (self.function_name if self.function_name != '__init__' else '') \
    + '(' + ", ".join(self.function_arguments if len(self.function_arguments) == 0 or self.function_arguments[0] != 'self' else self.function_arguments[1:]) + ")\n"
===
V indent = 0
V r = .newlines()‘’(‘ ’ * (indent * 3))‘F ’(I .function_name != ‘__init__’ {.function_name} E ‘’)‘(’(I .function_arguments.empty | .function_arguments[0] != ‘self’ {.function_arguments} E .function_arguments[1..]).join(‘, ’)")\n"


class ASTExpression:
    def to_str(self, indent):
        return ' ' * (indent*3) + self.expression.to_str() + "\n"
===
T ASTExpression
   F to_str(indent)
      R (‘ ’ * (indent * 3))‘’(.expression.to_str())"\n"


while True:
    if True: break
    a = 0
===
L
   I 1B
      L.break
   V a = 0


import test_deep_imports
print()
===
print()


def f1(b : bool, *, pos = 0):
   pass
def f2(b : bool, *, pos : int = 0):
   pass
===
F f1(Bool b; ', pos = 0)
{
}
F f2(Bool b, ', Int pos = 0)
{
}


def newtoncooling(time, temp): return -0.07 * (temp - 20)
===
F newtoncooling(time, temp)
   R -0.07 * (temp - 20)


def assign(values, s, d):
    "Eliminate all the other values (except d) from values[s] and propagate."
    global eliminate
    if all([eliminate(values, s, d2) for d2 in values[s] if d2 != d]):
        return values
    else:
        return None

def eliminate(values, s, d):
    "Eliminate d from values[s]; propagate when values or places <= 2."
    if d not in values[s]:
        return values ## Already eliminated
===
F assign(values, s, d)
   ‘Eliminate all the other values (except d) from values[s] and propagate.’
   I all(values[s].filter(d2 -> d2 != @d).map(d2 -> eliminate(@values, @s, d2)))
      R values
   E
      R N

F eliminate(values, s, d)
   ‘Eliminate d from values[s]; propagate when values or places <= 2.’
   I d !C values[s]
      R values


a : Tuple[int, int]
b : Tuple[Tuple[int, int], int]
c : Tuple[Tuple[int, Tuple[int, int]], int]
scorelist : List[Tuple[float, Tuple[int, int]]] = []
===
(Int, Int) a
((Int, Int), Int) b
((Int, (Int, Int)), Int) c
[(Float, (Int, Int))] scorelist


AB = 1
CD = 2
def f(i):
    print(AB)
    if i == AB:
        return 1
    elif i == CD:
        return 2
===
V AB = 1
V CD = 2
F f(i)
   print(:AB)
   I i == :AB
      R 1
   E I i == :CD
      R 2


import random, math

class Individual:
    def __init__(self):
        self.genome = [random.random() for i in range(10)]
    def computeValuesGenome(self, xMin=0, xMax=math.pi):
        pass
===
T Individual
   genome = (0.<10).map(i -> random:())
   F ()
   {
   }
   F computeValuesGenome(xMin = 0, xMax = math:pi)
   {
   }


'%4f' % (1.5)
'%8f' % (1.5)
'%9f' % (1.5)
'%9.5f' % (1.5)
'%4.0f' % (1.5)
'%2.f' % (1.5)
===
‘#.6’.format(1.5)
‘#.6’.format(1.5)
‘#2.6’.format(1.5)
‘#3.5’.format(1.5)
‘#4.0’.format(1.5)
‘#2.0’.format(1.5)


print('{:16.14f}'.format(0.5))
#print('{:16.14}'.format(0.5))
print('{:17.14f}'.format(0.5))
#print('{:17.14}'.format(0.5))
print('{:20.14f}'.format(0.5))
#print('{:20.14}'.format(0.5))
print('{:16f}'.format(0.5))
print('{:16}'.format(0.5))
print('{:03}'.format(1))
print('{}, {}, {}'.format('a', 'b', 'c'))
print('{0}, {1}, {2}'.format('a', 'b', 'c'))
print('{0}, {0}, {2}, {1}'.format('a', 'b', 'c'))
print('{0}, {0:2}, {2}, {1}'.format(1, 2, 3))
print(" group={group} off_by={group} polyphony={polyphony} off_mode=fast".format(group=1, polyphony=2))
print("\t<region> lovel={lovel:03} hivel={hivel:03} amp_velcurve_{hivel:03}=1".format(lovel=10, hivel=20))
print('{:<11} {:<36} {:<15} {:<15}'.format('Character', 'Name', 'Unicode', 'UTF-8 encoding (hex)'))
print('{:<11} {:<15} {:<15}'.format('Character', 'Unicode', 'UTF-8 encoding (hex)'))
print('# #. %d' % 7)
print('# #. {}'.format(7))
print("#%2i" % 2)
print("## Got %d" % 3)
===
print(‘#.14’.format(0.5))
print(‘#2.14’.format(0.5))
print(‘#5.14’.format(0.5))
print(‘#9.6’.format(0.5))
print(‘#16’.format(0.5))
print(‘#03’.format(1))
print(‘#., #., #.’.format(‘a’, ‘b’, ‘c’))
print(‘#., #., #.’.format(‘a’, ‘b’, ‘c’))
print(‘#., #., #., #.’.format(‘a’, ‘a’, ‘c’, ‘b’))
print(‘#., #2, #., #.’.format(1, 1, 3, 2))
print(‘ group=#. off_by=#. polyphony=#. off_mode=fast’.format(1, 1, 2))
print("\t<region> lovel=#03 hivel=#03 amp_velcurve_#03=1".format(10, 20, 20))
print(‘#<11 #<36 #<15 #<15’.format(‘Character’, ‘Name’, ‘Unicode’, ‘UTF-8 encoding (hex)’))
print(‘#<11 #<15 #<15’.format(‘Character’, ‘Unicode’, ‘UTF-8 encoding (hex)’))
print(‘# ##. #.’.format(7))
print(‘# ##. #.’.format(7))
print(‘###2’.format(2))
print(‘### Got #.’.format(3))


dates : List[datetime.date] = []
times : List[datetime.datetime] = []
===
[Time] dates
[Time] times


for i in range(700_000):
    pass
print(range(1, 1_000))
===
L(i) 700'000
{
}
print(1..999)


N = int(input())
print(N)
===
V _n_ = Int(input())
print(_n_)


(h, m) = (12, 5)
print('Hour:', h, 'minute:', m)
print('Hour: ', h, ', minute: ', m, sep = '')
print('Hour and min:', h, m)
r = 1
print('Result:', r)
print('Result:', r, sep = ' ')
print('Result:', r, sep = " ")
print('Result:', r, sep = "\t")
print('Result:', r, '.', sep = "\t")
print("\\Result:", r)
print("\\Result:", r, sep = ' ')
print("\\Result:", r, sep = " ")
print("\\Result:", r, sep = "\t")
===
V (h, m) = (12, 5)
print(‘Hour: ’h‘ minute: ’m)
print(‘Hour: ’h‘, minute: ’m)
print(‘Hour and min: ’h‘ ’m)
V r = 1
print(‘Result: ’r)
print(‘Result: ’r)
print(‘Result: ’r)
print(‘Result:’"\t"r)
print(‘Result:’"\t"r"\t"‘.’)
print("\\Result: "r)
print("\\Result: "r)
print("\\Result: "r)
print("\\Result:\t"r)


r = 1
arr = [2]
print('Result:', r)
print('Result:', arr[0])
print('Result:', 3)
print('Result:', r + 1)
print('Result: ', r + 1, end = '', sep = '')
print('Result: ', r + 1, sep = '', end = '')
print(end = 's')
(h, m, s, a, b) = (12, 5, 30, 50, 175)
print(h, m, s)
print(a, b % 100)
print(h, ':', m // 10, m % 10, ':', s // 10, s % 10, sep = '')
print(h, ':', m // 10, m % 10, ':', s // 10, s % 10)
===
V r = 1
V arr = [2]
print(‘Result: ’r)
print(‘Result: ’arr[0])
print(‘Result: ’(3))
print(‘Result: ’(r + 1))
print(‘Result: ’(r + 1), end' ‘’)
print(‘Result: ’(r + 1), end' ‘’)
print(end' ‘s’)
V (h, m, s, a, b) = (12, 5, 30, 50, 175)
print(h‘ ’m‘ ’s)
print(a‘ ’(b % 100))
print(h‘:’(m I/ 10)‘’(m % 10)‘:’(s I/ 10)‘’(s % 10))
print(h‘ : ’(m I/ 10)‘ ’(m % 10)‘ : ’(s I/ 10)‘ ’(s % 10))


primes = [True] * 10
primes[0] = primes[1] = False
primes[0] = primes[1] = primes[2] = False
===
V primes = [1B] * 10
primes[0] = primes[1] = 0B
primes[0] = primes[1] = primes[2] = 0B


arr = [1, 2, 3, 4]
del arr[2:4]
del arr[2:]
===
V arr = [1, 2, 3, 4]
arr.del(2.<4)
arr.del(2..)


def fn():
    return 1
print(fn())
===
F _fn_()
   R 1
print(_fn_())


cache : Dict[Tuple[int, int], Tuple[int, List[Tuple[int, str]]]] = {}
===
[(Int, Int) = (Int, [(Int, String)])] cache


d0 = {'a': 1}
for a in d0:
    print(a)
import collections
d = collections.defaultdict(int) # int
for a in d:
    print(a)
===
V d0 = [‘a’ = 1]
L(a) d0.keys()
   print(a)
V d = DefaultDict[Int, Int]()
L(a) d.keys()
   print(a)


m = int(input())
d = {q.lower(): q for q in [input() for i in range(m)]}
e = {q.lower(): q for q in [input() for i in range(m)] if len(q) > 1}
===
V m = Int(input())
V d = Dict((0 .< m).map(i -> input()), q -> (q.lowercase(), q))
V e = Dict((0 .< m).map(i -> input()).filter(q -> q.len > 1), q -> (q.lowercase(), q))


for i, a in enumerate([1, 2, 3, 4, 5]):
    a -= 1
    i -= 1
    print(a, i)
===
L(=a) [1, 2, 3, 4, 5]
   V i = L.index
   a--
   i--
   print(a‘ ’i)


for i, a in enumerate([1, 2, 3, 4, 5], start = 2):
    print(a, i)
===
L(a) [1, 2, 3, 4, 5]
   V i = L.index + 2
   print(a‘ ’i)


def order_disjoint_list_items(data : list, items):
    data[0] = items[0]

for data, items in [('the cat sat on the mat'.split(' '), ('mat cat').split(' '))]:
    order_disjoint_list_items(data, items)
===
F order_disjoint_list_items(&data, items)
   data[0] = items[0]

L(data, items) [(‘the cat sat on the mat’.split(‘ ’), (‘mat cat’).split(‘ ’))]
   order_disjoint_list_items(&data, items)


arr : List[int] = []
arr += [i*2 for i in range(10)]
===
[Int] arr
arr [+]= (0.<10).map(i -> i * 2)


def get_f(a, b):
    def f(c):
        nonlocal a, b # =
        return a + b + c
    return f
===
F get_f(a, b)
   F f(c)
      R @=a + @=b + c
   R f


import os

class EXSSamplePool:

    locations : List[str]

    def __init__(self):
        self.locations = []

class EXSSamplePoolLocator(EXSSamplePool):

    base : str

    def __init__(self, exsfile_name):
        self.base = os.path.dirname(exsfile_name)
        super().__init__()
===
T EXSSamplePool

   [String] locations

   F ()
   {
   }

T EXSSamplePoolLocator(EXSSamplePool)

   String base

   F (exsfile_name)
      .base = fs:path:dir_name(exsfile_name)


def gnomesort(a : list):
    return a

print(gnomesort([3,4,2,5,1,6]))
print(gnomesort(a = [3,4,2,5,1,6]))
===
F gnomesort(&a)
   R a

print(gnomesort(&[3, 4, 2, 5, 1, 6]))
print(gnomesort(a' &[3, 4, 2, 5, 1, 6]))


from typing import List

def f(l : List[int] = None):
    if l is None:
        l = []
    l.append(1)
    print(l)

f()
f()

def f2(l : List[int] = None, l2 : List[int] = None):
    if l is None:
        l = []
    if l2 is None:
        l2 = []
    print(l)
===
F f([Int] &l = [Int]())
   l.append(1)
   print(l)

f()
f()

F f2([Int] &l = [Int](), [Int] &l2 = [Int]())
   print(l)


from typing import List

def f(l : List[int] = None):
    if l is None:
        l = [0, 2]
    l.append(1)
    print(l)

f()
f()
===
F f([Int] &l = [0, 2])
   l.append(1)
   print(l)

f()
f()


table = [[0]*0 for i in range(10)]
ar4x5 = [[0]*5 for i in range(4)]
f45 = [[0.0]*5 for i in range(4)]
def f(size):
    a = [[0]*size for i in range(size)]
    ncols = 3
    nrows = 4
    board = [[-1] * (ncols + 2) for _ in range(nrows + 2)]
N = int(input())
dp = [[0] * (i+1) for i in range(N+1)]
===
V table = [[Int]()] * 10
V ar4x5 = [[0] * 5] * 4
V f45 = [[0.0] * 5] * 4
F f(size)
   V a = [[0] * size] * size
   V ncols = 3
   V nrows = 4
   V board = [[-1] * (ncols + 2)] * (nrows + 2)
V _n_ = Int(input())
V dp = (0 .. _n_).map(i -> [0] * (i + 1))


def gen_row(w, s):
  def gen_seg(o : List[int]):
      gen_seg(o)
===
F gen_row(w, s)
   F gen_seg([Int] &o)
      @gen_seg(&o)


descendants = [1]
print("Descendants:", len(descendants) if len(descendants) else -1)
===
V descendants = [1]
print(‘Descendants: ’(I !descendants.empty {descendants.len} E -1))


x = 10
print(hex(x)[2:].upper())
print(hex(x)[2:])
print(hex(x))
===
V x = 10
print(hex(x))
print((‘0x’hex(x).lowercase())[2..])
print((‘0x’hex(x).lowercase()))


arr = [[1], [2], [3]]
for a in arr: # &
    a.append(4)
for i, a in enumerate(arr): # &
    a.append(i)
===
V arr = [[1], [2], [3]]
L(&a) arr
   a.append(4)
L(&a) arr
   V i = L.index
   a.append(i)


a = .5
b = 2.
===
V a = .5
V b = 2.


ppm = open('sand_pile.ppm', 'wb')
ppm.write("P6\n2 2\n255\n".encode())
ppm.write(bytes([Byte(255), 0, 0]))
===
V ppm = File(‘sand_pile.ppm’, WRITE)
ppm.write_bytes("P6\n2 2\n255\n".encode())
ppm.write_bytes([Byte(255), 0, 0])


open('tmp.ppm', 'wb').write(b"P6\n")
===
File(‘tmp.ppm’, WRITE).write_bytes(Bytes("P6\n"))


from _11l import *

class BitWriter:
    out : BinaryOutput

    def flush(self):
        self.out.write(b'A')

class BitReader:
    input : BinaryIO

    def _readbit(self):
        a = self.input.read(1)
===
T BitWriter
   File[WRITE] out

   F flush()
      .out.write_bytes('A'.code)

T BitReader
   File input

   F _readbit()
      V a = .input.read_bytes(at_most' 1)


print("="*54)
print(10*" " + "left:" + 21*" " + "right: ")
print(" "*10 + "left:" + " "*21 + "right: ")
left = input()
right = input()
print(10*" " + left + 21*" " + right)
print(" "*10 + left + " "*21 + right)
===
print(‘=’ * 54)
print((10 * ‘ ’)‘left:’(21 * ‘ ’)‘right: ’)
print((‘ ’ * 10)‘left:’(‘ ’ * 21)‘right: ’)
V left = input()
V right = input()
print((10 * ‘ ’)‘’left‘’(21 * ‘ ’)‘’right)
print((‘ ’ * 10)‘’left‘’(‘ ’ * 21)‘’right)


def f(a, b):
    return a + [] + b
===
F f(a, b)
   R a [+] b


demo1 = [b"", Bytes("a"), b"abc"]
demo2 = [b"", bytes(b"a"), b"abc"]
===
V demo1 = [Bytes(‘’), Bytes(‘a’), Bytes(‘abc’)]
V demo2 = [Bytes(‘’), Bytes(‘a’), Bytes(‘abc’)]


# [https://www.rosettacode.org/wiki/Addition_chains#Python]
n = 7
best = [1, 2]
print(f'L({n}) = {len(best)}')
print(f'L({n}) = {len(best) - 1}')
print(f'''L({n}) = {len(best) - 1}''')
print(f'L({n}) = {len(best) - 1:2}')
print(f"""L({n}) = {len(best) - 1:2}""")

# [https://www.rosettacode.org/wiki/Bin_given_limits#Python]
limits = [1]
bins = [2]
print(f"          < {limits[0]:3} := {bins[0]:3}")

# [https://www.rosettacode.org/wiki/Bioinformatics/base_count#Python]
(i, n, part) = (1, 2, 3)
print(f"{i*n:>5}: {part}")
print(f"{i*n:<5}: {part}")
print(f"{i*n:>5}: {{part}}")
print(f"{i*n:>5}: {{pa")
print(f"{i*n:>5}: rt}}")
print(f"{i*n:>5}: {{{part}}}")
print(f"{i*n:>5}:\t{part}")
print(f"{i*n}: {part}")
print(f"{i*n}: {{part}}")
print(f"{i*n}: {{pa")
print(f"{i*n}: rt}}")
print(f"{i*n}: {{{part}}}")
print(f"{i*n}:\t{part}")
print(f"{i*n}{str(part)}")

# [https://www.rosettacode.org/wiki/Price_list_behind_API#Python]
import random
price_list_size = 100_000
price_list = [random.randrange(100_000) for i in range(price_list_size)]
def get_max_price():
    return max(price_list)
print(f"Using {price_list_size} random prices from 0 to {get_max_price()}")
(mn, mx, count) = (1.1, 2.2, 3)
print(f"  From {mn:8.1f} ... {mx:8.1f} with {count} items.")
print("  From {:8.1f} ... {:8.1f} with {} items.".format(mn, mx, count))

v = 0.5
print(f'{v:16.14f}')
#print(f'{v:16.14}')
print('{:16.14f}'.format(v))
print(f'{v:17.14f}')
print('{:17.14f}'.format(v))
print(f'{v:20.14f}')
print('{:20.14f}'.format(v))
print(f'{v:020.14f}')
print(f'{v:16f}')
print('{:16f}'.format(v))
o = 1
print(f'{o:03}')
print('{:03}'.format(o))
print(f'{f"{o:03}"}')
print(f'{f"{o}":>3}')
===
V n = 7
V best = [1, 2]
print(‘L(’n‘) = ’best.len)
print(‘L(’n‘) = ’(best.len - 1))
print(‘L(’n‘) = ’(best.len - 1))
print(f:‘L({n}) = {best.len - 1:2}’)
print(f:‘L({n}) = {best.len - 1:2}’)

V limits = [1]
V bins = [2]
print(f:‘          < {limits[0]:3} := {bins[0]:3}’)

(V i, n, V part) = (1, 2, 3)
print(f:‘{i * n:5}: {part}’)
print(f:‘{i * n:<5}: {part}’)
print(f:‘{i * n:5}: {{part}}’)
print(f:‘{i * n:5}: {{pa’)
print(f:‘{i * n:5}: rt}}’)
print(f:‘{i * n:5}: {{{part}}}’)
print(f:"{i * n:5}:\t{part}")
print((i * n)‘: ’part)
print((i * n)‘: {part}’)
print((i * n)‘: {pa’)
print((i * n)‘: rt}’)
print((i * n)‘: {’part‘}’)
print((i * n)":\t"part)
print((i * n)‘’String(part))
V price_list_size = 100'000
V price_list = (0 .< price_list_size).map(i -> random:(100'000))
F get_max_price()
   R max(:price_list)
print(‘Using ’price_list_size‘ random prices from 0 to ’get_max_price())
V (mn, mx, count) = (1.1, 2.2, 3)
print(f:‘  From {mn:8.1} ... {mx:8.1} with {count} items.’)
print(‘  From #6.1 ... #6.1 with #. items.’.format(mn, mx, count))

V v = 0.5
print(f:‘{v:16.14}’)
print(‘#.14’.format(v))
print(f:‘{v:17.14}’)
print(‘#2.14’.format(v))
print(f:‘{v:20.14}’)
print(‘#5.14’.format(v))
print(f:‘{v:020.14}’)
print(f:‘{v:16.6}’)
print(‘#9.6’.format(v))
V o = 1
print(f:‘{o:03}’)
print(‘#03’.format(o))
print((f:‘{o:03}’))
print(f:‘{o:3}’)


# [https://www.python.org/dev/peps/pep-0585/ <- [https://docs.python.org/3/library/typing.html]:‘Deprecated since version 3.9’]
t : tuple[int, float]
l : list[int] = []
d : dict[int, str] = {}

class Obj:
    s : set[int]

import collections

def f(l : list[int], d : collections.defaultdict[str, list[str]]) -> list[float]:
    return [float(l[0])]

anagram : collections.defaultdict[str, list[str]] = collections.defaultdict(list)
f(l, anagram)
===
(Int, Float) t
[Int] l
[Int = String] d

T Obj
   Set[Int] s

F f([Int] &l, DefaultDict[String, [String]] &d) -> [Float]
   R [Float(l[0])]

DefaultDict[String, [String]] anagram
f(&l, &anagram)


for n in list(range(1, 11)) + list(range(95, 106)) + [297, 576, 594, 891, 909, 999, 1998, 2079, 2251, 2277, 2439, 2997, 4878]:
    print(n)
===
L(n) Array(1..10) [+] Array(95..105) [+] [297, 576, 594, 891, 909, 999, 1998, 2079, 2251, 2277, 2439, 2997, 4878]
   print(n)


g = 0

for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    assert(len(a) == n)

    moves = 0
    def mov(i, j, k):
        global moves # @
        global g
        g = 1
        a[i] += 1
        a[j] -= 2
        a[k] += 1
        moves += 1
===
V g = 0

L(_) 0 .< Int(input())
   V n = Int(input())
   V a = input().split_py().map(Int)
   assert(a.len == n)

   V moves = 0
   F mov(i, j, k)
      :g = 1
      @a[i]++
      @a[j] -= 2
      @a[k]++
      @moves++


# [https://codeforces.com/contest/1633/submission/146570768]
Char = str

def solve(n):
    ns = list(str(n))
    for i in range(len(ns)):
        for d in range(1 if i == 0 else 0, 10):
            nn = ns[:]
            nn[i] = Char(int(d))
            if int(''.join(nn)) % 7 == 0:
                return int(''.join(nn))
    raise 0
===
F solve(n)
   V ns = Array(String(n))
   L(i) 0 .< ns.len
      L(d) (I i == 0 {1} E 0) .< 10
         V nn = copy(ns)
         nn[i] = Char(digit' d)
         I Int(nn.join(‘’)) % 7 == 0
            R Int(nn.join(‘’))
   X.throw 0


# [https://codeforces.com/contest/1626/submission/146679304]
for _ in range(int(input())):
    n = input()

    for i in range(1, len(n)):
        print(n[i-1] + n[i])

# [https://codeforces.com/contest/1616/submission/146711179]
for _ in range(int(input())):
    n = int(input())
    s = input()
    assert(len(s) == n)

    r = s + s[::-1]
    for k in range(1, len(s)):
        t = s[:k] + s[k-1::-1]
        if t < r:
            r = t

    print(r)
===
L(_) 0 .< Int(input())
   V n = input()

   L(i) 1 .< n.len
      print(n[i - 1]‘’n[i])

L(_) 0 .< Int(input())
   V n = Int(input())
   V s = input()
   assert(s.len == n)

   V r = s‘’reversed(s)
   L(k) 1 .< s.len
      V t = s[0 .< k]‘’s[(k - 1 ..).step(-1)]
      I t < r
         r = t

   print(r)


def foo():
    return 1, 2

def bar():
    return 1, 2, 3
===
F foo()
   R (1, 2)

F bar()
   R (1, 2, 3)


a, b = map(int, input().split())
(c, d) = map(int, input().split())
===
V (a, b) = input().split_py().map(Int)
V (c, d) = input().split_py().map(Int)


a, b = 1, 2
(c, d) = (1, 2)
a, b = b, a
===
V (a, b) = (1, 2)
V (c, d) = (1, 2)
swap(&a, &b)


a = [1, 2]
a[0], a[1] = a[1], 1
a[0], a[1] = a[1], a[0]
===
V a = [1, 2]
(a[0], a[1]) = (a[1], 1)
swap(&a[0], &a[1])


# [https://codeforces.com/contest/1579/submission/146984105]
for _ in range(int(input())):
    s = input()

    cA = s.count('A')
    cB = s.count('B')
    cC = s.count('C')

    def solve():
        global cA, cB, cC # @

        while True:
            if cA > cC: # удаляем A и B
                cA -= 1
                cB -= 1
                if cB < 0:
                    return False
            else: # удаляем B и C
                cB -= 1
                cC -= 1
                if cB < 0 or cC < 0:
                    return False
            if cA == cB == cC == 0:
                return True

    if solve():
        print('YES')
    else:
        print('NO')
===
L(_) 0 .< Int(input())
   V s = input()

   V cA = s.count(‘A’)
   V cB = s.count(‘B’)
   V cC = s.count(‘C’)

   F solve()

      L
         I @cA > @cC
            @cA--
            I --@cB < 0
               R 0B
         E
            @cB--
            @cC--
            I @cB < 0 | @cC < 0
               R 0B
         I @cA == @cB == @cC == 0
            R 1B

   I solve()
      print(‘YES’)
   E
      print(‘NO’)


# from [https://codeforces.com/contest/1521/submission/117139834]
C : List[int] = []
C += [1] * 2
B : List[int] = []
border = 3
D = B[border:]
D += C[border:]
===
[Int] _c_
_c_ [+]= [1] * 2
[Int] B
V border = 3
V D = B[border ..]
D [+]= _c_[border ..]


ans = [1]
print(f'! {len(ans)} '+" ".join(map(str, ans)))
print(f'! {len(ans)}'+" ".join(map(str, ans)))
===
V ans = [1]
print(‘! ’ans.len‘ ’ans.map(String).join(‘ ’))
print(‘! ’ans.len‘’ans.map(String).join(‘ ’))


ans = [i for i in range(10)]
ant = list(range(10))
n = 9
s = sum(i for i in range(1, n + 1)) # [https://github.com/nayuki/Project-Euler-solutions/blob/master/python/p006.py?ts=4#L17]
s = sum([i for i in range(1, n + 1)])
===
V ans = Array(0.<10)
V ant = Array(0.<10)
V n = 9
V s = sum((1 .. n))
s = sum(Array(1 .. n))


a = [1, 2, 3]
a[-2:] = reversed(a[-2:])
a[-2:] = a[-2:][::-1]
===
V a = [1, 2, 3]
a.reverse_range((len)-2 ..)
a.reverse_range((len)-2 ..)


DIGITS = 55
save : List[Dict[int, int]] = [{} for d in range(DIGITS)]
savf : List[Dict[int, int]] = [dict() for d in range(DIGITS)]
===
V DIGITS = 55
[[Int = Int]] save = (0 .< DIGITS).map(d -> [Int = Int]())
[[Int = Int]] savf = (0 .< DIGITS).map(d -> [Int = Int]())


class Flow:
    g : List[Dict[int, float]]
    h : List[Dict[int, float]]

    def __init__(self, n):
        self.g = [{} for _ in range(n)]
        self.h = [dict() for _ in range(n)]
===
T Flow
   [[Int = Float]] g
   [[Int = Float]] h

   F (n)
      .g = (0 .< n).map(_ -> [Int = Float]())
      .h = (0 .< n).map(_ -> [Int = Float]())


for _ in range(int(input())):
    re = {1, 2}
    re.discard(1)
===
L(_) 0 .< Int(input())
   V re = Set([1, 2])
   re.discard(1)


# *[https://codeforces.com/contest/1447/submission/98523271]
import collections
n = int(input())
A = list(map(int, input().split()))
cnt = collections.Counter(A)
maxv = max(cnt.values())
xx = [c for c in cnt.keys() if cnt[c] == maxv]
if len(xx) > 1:
    print(n)
else:
    x = xx[0]
    ans = 0
    for c in cnt:
        if c == x: continue
        dic = {0: -1}
        cur = 0
        tmp = 0
        for i, a in enumerate(A):
            cur += 1 if a == c else -1 if a == x else 0
            if cur in dic:
                tmp = max(tmp, i - dic[cur])
            dic.setdefault(cur, i)
        ans = max(ans, tmp)
    print(ans)
===
V n = Int(input())
V A = input().split_py().map(Int)
V cnt = Counter(A)
V maxv = max(cnt.values())
V xx = cnt.keys().filter(c -> :cnt[c] == :maxv)
I xx.len > 1
   print(n)
E
   V x = xx[0]
   V ans = 0
   L(c) cnt.keys()
      I c == x
         L.continue
      V dic = [0 = -1]
      V cur = 0
      V tmp = 0
      L(a) A
         V i = L.index
         cur += I a == c {1} E I a == x {-1} E 0
         I cur C dic
            tmp = max(tmp, i - dic[cur])
         dic.set_default(cur, i)
      ans = max(ans, tmp)
   print(ans)


S = [1, 2, 3, 4]
def poke(n):
    global S
    S = S[:2] + S[3:]
===
V _s_ = [1, 2, 3, 4]
F poke(n)
   :_s_ = :_s_[0.<2] [+] :_s_[3..]


import math
print(math.prod([2, 3]))
===
print(product([2, 3]))


def solve():
  r, g, b = map(int, input().split())
  dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]
===
F solve()
   V (r, g, b) = input().split_py().map(Int)
   V dp = (0 .. r).map(_ -> [[0] * (@b + 1)] * (@g + 1))


from typing import ClassVar, Dict

class Starship:
    stats: ClassVar[Dict[str, int]] = {}
    i1 : ClassVar[int]
    i2 : ClassVar[int] = 1
    i3 : ClassVar = 2

    @staticmethod
    def set_i1(a, b):
        Starship.i1 = a + b

print(Starship.stats)
Starship.set_i1(1, 2)
print(Starship.i1)
===
T Starship
   [String = Int] :stats
   Int :i1
   Int :i2 = 1
   :i3 = 2

   F :set_i1(a, b)
      Starship.:i1 = a + b

print(Starship.:stats)
Starship.set_i1(1, 2)
print(Starship.:i1)


import array, itertools

n = 64000000
quasiprimefactor = array.array("H", (0 for _ in range(n + 1)))
quasiprimefactoR = array.array("H", (0 for _ in range(n)))
sigma2 = array.array("Q", (0 for _ in range(n + 1)))
totientchainlen = array.array("L", [0, 1])
result = array.array("L", range(n + 1))
smallestprimefactor = array.array("L", itertools.repeat(0, n + 1))
smallestprimefactoR = array.array("L", itertools.repeat(0, n))
===
V n = 64000000
V quasiprimefactor = [UInt16(0)] * (n + 1)
V quasiprimefactoR = [UInt16(0)] * n
V sigma2 = [UInt64(0)] * (n + 1)
V totientchainlen = [UInt32(0), 1]
V result = Array(UInt32(0) .< UInt32(n + 1))
V smallestprimefactor = [UInt32(0)] * (n + 1)
V smallestprimefactoR = [UInt32(0)] * n


# [https://rosettacode.org/wiki/Count_the_coins/0-1]
from typing import List

class Solver:
    def count(self, rindices: List[int]) -> None:
        self.count(rindices)

solver = Solver()
rindices = list(range(10))
solver.count(rindices)
===
T Solver
   F count([Int] &rindices) -> Void
      .count(&rindices)

V solver = Solver()
V rindices = Array(0.<10)
solver.count(&rindices)


# [https://rosettacode.org/wiki/Cyclops_numbers#Python]
i = 100000
print(f'... at position {i:,}')
===
V i = 100000
print(f:‘... at position {commatize(i)}’)


# [https://rosettacode.org/wiki/Knuth-Morris-Pratt_string_search#Python]
text, word = "GCTAGCTCTACGAGTCTA", "TCTA"
print(f"`{word}` not found in `{text[:10]}...`")
===
V (text, word) = (‘GCTAGCTCTACGAGTCTA’, ‘TCTA’)
print(‘`’word‘` not found in `’text[0.<10]‘...`’)


Char = str

direction: str
v = 1
if v in (1, 5, 13):
    direction = 'N'
elif v in (2, 3, 7):
    direction = 'E'
elif v == 6:
    direction = 'W'
else:
    raise RuntimeError('Illegal state.')

dir = Char('E')
if dir in ('N', 'W'):
    v = 1
elif dir == 'E':
    v = 2

dir2 = Char('E')
if dir2 in ('NE', 'W'):
    v = 1
elif dir2 == 'E':
    v = 2
===
String direction
V v = 1
S v
   1, 5, 13
      direction = ‘N’
   2, 3, 7
      direction = ‘E’
   6
      direction = ‘W’
   E
      X.throw RuntimeError(‘Illegal state.’)

S Char(‘E’)
   ‘N’, ‘W’
      v = 1
   ‘E’
      v = 2

S Char(‘E’)
   ‘NE’, ‘W’
      v = 1
   ‘E’
      v = 2


Char = str

def calc(op, op1, op2):
    match op:
        case '-':
            return op1 - op2
        case '+':
            return op1 + op2
        case _:
            assert False, f'Unknown operation `{op}`'

print(calc(Char('+'), 1, 2))
calc(Char('*'), 1, 2)
===
F calc(op, op1, op2)
   S op
      ‘-’
         R op1 - op2
      ‘+’
         R op1 + op2
      E
         assert(0B, ‘Unknown operation `’op‘`’)

print(calc(Char(‘+’), 1, 2))
calc(Char(‘*’), 1, 2)


matches = ['a', 'b']
for match in matches:
    print(match)
===
V matches = [‘a’, ‘b’]
L(match) matches
   print(match)


match input('?'):
    case '1':
        print(1)
    case '2':
        print(2)
    case '3'|'4':
        print('3 | 4')
    case '5'|'6'|'7':
        print('5 | 6 | 7')
===
S input(‘?’)
   ‘1’
      print(1)
   ‘2’
      print(2)
   ‘3’, ‘4’
      print(‘3 | 4’)
   ‘5’, ‘6’, ‘7’
      print(‘5 | 6 | 7’)


vowels_set = set('аеёиоуыэюяАЕЁИОУЫЭЮЯ')
===
V vowels_set = Set(Array(‘аеёиоуыэюяАЕЁИОУЫЭЮЯ’))


if (l := input()) != '':
    print(l)

code = ''
while (line := input()) != '':
    code += line + "\n"

print('Your code:')
print(code)
===
I (V l = input()) != ‘’
   print(l)

V code = ‘’
L (V line = input()) != ‘’
   code ‘’= line"\n"

print(‘Your code:’)
print(code)


print(oct(511))
===
print((‘0o’String(511, radix' 8)))


import os
f = open('...')
f.seek( 4, 1)
f.seek( 4, os.SEEK_CUR)
f.seek(-4, os.SEEK_END)
f.seek( 0, os.SEEK_END)
f.seek( 0, 2)
===
V f = File(‘...’)
f. .seek(.tell() + 4)
f. .seek(.tell() + 4)
f. .seek(.get_file_size() + -4)
f. .seek(.get_file_size())
f. .seek(.get_file_size())


line = line.split(';', maxsplit = 1)[0]
===
V line = line.split(‘;’, 1 + 1)[0]


class Token:
    pass
indent_f: Callable[[List[Token]], str]

print(indent_f([Token()]) + indent_f([Token()]))
===
T Token
{
}
([Token] -> String) indent_f

print(indent_f([Token()])‘’indent_f([Token()]))


def get_comment() -> str:
    return ' '

comment = get_comment()
if True:
    comment += get_comment()
===
F get_comment() -> String
   R ‘ ’

V comment = get_comment()
I 1B
   comment ‘’= get_comment()


def simd_to_symasm(mnem, ops: List[str]):
    return ops[0] + mnem[-1] + ' |=| 0'
===
F simd_to_symasm(mnem, [String] &ops)
   R ops[0]‘’mnem.last‘ |=| 0’


def simd_to_symasm(mnem, ops: List[str]):
    instruction_template, ty = ('<dst> v= <src>', 's')
    ops[0] += ty
===
F simd_to_symasm(mnem, [String] &ops)
   V (instruction_template, ty) = (‘<dst> v= <src>’, ‘s’)
   ops[0] ‘’= ty


def trans_char_keep_case(ch, fr: Char, to: Char) -> Char:
    return chr(ord(ch) + (ord(to) - ord(fr)))

for token in ['r8d']:
    print(token[:-1] + trans_char_keep_case(token[-1], 'd', 'i'))
===
F trans_char_keep_case(ch, Char fr, Char to) -> Char
   R Char(code' ch.code + (to.code - fr.code))

L(token) [‘r8d’]
   print(token[0 .< (len)-1]‘’trans_char_keep_case(token.last, ‘d’, ‘i’))


class RangeIterator:
    cur: int
    end: int

    def __init__(self, start, end):
        self.cur = start - 1
        self.end = end

    def __iter__(self):
        return self

    def __next__(self):
        self.cur += 1
        if self.cur == self.end:
            raise StopIteration()
        return self.cur

for i in RangeIterator(1, 10):
    print(i)
===
T RangeIterator
   Int cur
   Int end

   F (start, end)
      .cur = start - 1
      .end = end

   F next() X(StopIteration)
      .cur++
      I .cur == .end
         X StopIteration()
      R .cur

L(i) RangeIterator(1, 10)
   print(i)


mnemonics: Dict[str, int] = {}
mnem = 'mov'
s = f'x{mnemonics[mnem]}'.rjust(6) + ' '
===
[String = Int] mnemonics
V mnem = ‘mov’
V s = (‘x’mnemonics[mnem]).rjust(6)‘ ’