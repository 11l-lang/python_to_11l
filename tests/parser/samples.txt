def sum(x, y):
    r = x + y
    return r
===
F sum(x, y)
   r = x + y
   R r


message : str
pos : int = 0
type_args : List[str]
t : Tuple[str, int]
===
String message
Int pos = 0
Array[String] type_args
Tuple[String, Int] t


# Test for some class based on class Exception
class MyException(Exception):
    message : str
    line : int
    column : int
    pos : int

    def __init__(self, message, line, column, pos):
        self.message = message
        self.line = line
        self.column = column
        self.pos = pos
===
T MyException
   String message
   Int line
   Int column
   Int pos

   F (message, line, column, pos)
      .message = message
      .line = line
      .column = column
      .pos = pos


# Test for some class which is not based on other one
class Person:
    name : str
    age : int

    def __init__(name, age):
        self.name = name
        self.age  = age
===
T Person
   String name
   Int age

   F (name, age)
      .name = name
      .age = age


# Test for some class based on non Exception class
class Shape:
    position : Tuple[int, int]

class Circle(Shape):
    radious : int
===
T Shape
   Tuple[Int, Int] position

T Circle(Shape)
   Int radious


---
def get_newline_chars():
    newline_chars = []
    i = 0
    while i < len(instr):
        if instr[i] == "\r" or (instr[i] == "\n" and instr[i-1:i] != "\r"):
            newline_chars += [i]
        i += 1
    return newline_chars
===
F get_newline_chars()
    A i = 0
    L i < instr.len
        I instr[i] == "\r" | (instr[i] == "\n" & instr[i-1.<i] != "\r"):
            R [+]= i
        i++


(1,)
===
(1,)


prev_indentation_level = indentation_levels[-1] if len(indentation_levels) else 0
if len(indentation_levels):
    prev_indentation_level = indentation_levels[-1]
#else:
#    prev_indentation_level = 0
[1, 2]
===
prev_indentation_level = I !indentation_levels.empty {indentation_levels.last} E 0
I !indentation_levels.empty
   prev_indentation_level = indentation_levels.last
[1, 2]


---
E
   prev_indentation_level = 0


---
def sign(x):
    if x < 0:
        return -1
    elif x > 0:
        return 1
    else:
        return 0
===
F sign(x)
   I x < 0
      R -1
   E I x > 0
      R 1
   E
      R 0


---
key : str
if token.category in (Token.Category.NUMERIC_LITERAL, Token.Category.STRING_LITERAL):
    key = '(literal)'
elif token.category == Token.Category.NAME:
    key = '(name)'
elif token.category == Token.Category.CONSTANT:
    key = '(constant)'
elif token.category in (Token.Category.STATEMENT_SEPARATOR, Token.Category.DEDENT):
    key = ';'
else:
    key = token.value(source)
===
String key = S token.category
   NUMERIC_LITERAL, STRING_LITERAL
      ‘(literal)’
   NAME
      ‘(name)’
   CONSTANT:
      ‘(constant)’'
   STATEMENT_SEPARATOR, DEDENT
      ‘;’
   E
      token.value(source)


---
def find_ending_sq_bracket(str, i, start = 0):
    starti = i
    assert(str[i] == "[") # ]
    nesting_level = 0
    while True:
        ch = str[i]
        if ch == "[":
            nesting_level += 1
        elif ch == "]":
            nesting_level -= 1
            if nesting_level == 0:
                return i
        i += 1
        if i == len(str):
            exit_with_error('Unended comment started', start + starti)
===
F find_ending_sq_bracket(str, i, start = 0)
   A starti = i
   assert(str[i] == ‘[’)
   A nesting_level = 0
   L
      S str[i]
         ‘[’
            nesting_level++
         ‘]’
            I --nesting_level == 0
               return i
      i++
      I i == str.len
          exit_with_error(‘Unended comment started’, start + starti)
// balancing ]


str[:-1]
str[1:]
str[:1:]
str[1:2]
str[3:10:2]
str[3:10:]
===
str[0.<(len)-1]
str[1..]
str[0.<1]
str[1.<2]
str[(3.<10).step(2)]
str[3.<10]


---
def to_str(self, indent):
    return super().to_str(indent)[:-1] + ' = ' + self.expression.to_str() + "\n"
===
F to_str(indent)
   R T.super.to_str(indent)[0.<(len)-1]‘ = ’(.expression.to_str())"\n"


---
link = 'http://...'
tag = '<a href="' + link + '"'
tag += html_escapeq()
===
A link = ‘http://...’
A tag = ‘<a href="’link‘"’
tag ‘’= html_escapeq()


---
str1 = '1'
str2 = '2'
# str = str1 + str2 # rarely needed, so write this:
str = str1 + '' + str2
===
A str1 = ‘1’
A str2 = ‘2’
A str = str1‘’str2


if (a and b) or c:
    if a and (b or c):
        return
if (self.parent == None and isinstance(self.ast_parent, ASTIf)) or (self.parent != None and self.parent.symbol.id == 'if'):
    return
===
I (a & b) | c
   I a & (b | c)
      R
I (.parent == N & T(.ast_parent) >= ASTIf) | (.parent != N & .parent.symbol.id == ‘if’)
   R


l = lambda: None
l = lambda x: x[0]
l = lambda self: self # `self` here should not be replaced with ``
l = lambda x, y, reverse = False: y < x if reverse else x < y
===
l = () -> N
l = x -> x[0]
l = self -> self
l = (x, y, reverse = 0B) -> I reverse {y < x} E x < y


class Object:
    pass

def f():
    pass
===
T Object
{
}

F f()
{
}