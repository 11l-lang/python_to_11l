def sum(x, y):
    r = x + y
    return r
===
F sum(x, y)
   A r = x + y
   R r


message : str
pos : int = 0
type_args : List[str]
t : Tuple[str, int]
===
String message
Int pos = 0
Array[String] type_args
Tuple[String, Int] t


# Test for some class based on class Exception
class MyException(Exception):
    message : str
    line : int
    column : int
    pos : int

    def __init__(self, message, line, column, pos):
        self.message = message
        self.line = line
        self.column = column
        self.pos = pos
===
T MyException
   String message
   Int line
   Int column
   Int pos

   F (message, line, column, pos)
      .message = message
      .line = line
      .column = column
      .pos = pos


# Test for some class which is not based on other one
class Person:
    name : str
    age : int

    def __init__(name, age):
        self.name = name
        self.age  = age
===
T Person
   String name
   Int age

   F (name, age)
      .name = name
      .age = age


# Test for some class based on non Exception class
class Shape:
    position : Tuple[int, int]

class Circle(Shape):
    radious : int
===
T Shape
   Tuple[Int, Int] position

T Circle(Shape)
   Int radious


def to_html(self, instr):
    def get_newline_chars():
        newline_chars = []
        i = 0
        while i < len(instr):
            if instr[i] == "\r" or (instr[i] == "\n" and instr[i - 1:i] != "\r"):
                newline_chars += [i]
            i += 1
        return newline_chars
===
F to_html(instr)
   F get_newline_chars()
      A newline_chars = []
      A i = 0
      L i < @instr.len
         I @instr[i] == "\r" | (@instr[i] == "\n" & @instr[i - 1.<i] != "\r")
            newline_chars [+]= i
         i++
      R newline_chars


---
===
F to_html(instr)
   F get_newline_chars()
      A i = 0
      L i < @instr.len
         I @instr[i] == "\r" | (@instr[i] == "\n" & @instr[i - 1.<i] != "\r")
            R [+]= i
         i++


arr = []
arr += [1, 2]
===
A arr = []
arr [+]= [1, 2]


(1,)
===
(1,)


indentation_levels : List[int]
prev_indentation_level = indentation_levels[-1] if len(indentation_levels) else 0
if len(indentation_levels):
    prev_indentation_level = indentation_levels[-1]
else:
    prev_indentation_level = 0
def f(): # test for error when instead of `s = self \n while not s.is_function:` was `s = self.parent \n while s != None and not s.is_function:`
    prev_indentation_level = 0
[1, 2]
===
Array[Int] indentation_levels
A prev_indentation_level = I !indentation_levels.empty {indentation_levels.last} E 0
I !indentation_levels.empty
   prev_indentation_level = indentation_levels.last
E
   prev_indentation_level = 0
F f()
   A prev_indentation_level = 0
[1, 2]


def sign(x):
    if x < 0:
        return -1
    elif x > 0:
        return 1
    else:
        return 0
===
F sign(x)
   I x < 0
      R -1
   E I x > 0
      R 1
   E
      R 0


---
key : str
if token.category in (Token.Category.NUMERIC_LITERAL, Token.Category.STRING_LITERAL):
    key = '(literal)'
elif token.category == Token.Category.NAME:
    key = '(name)'
elif token.category == Token.Category.CONSTANT:
    key = '(constant)'
elif token.category in (Token.Category.STATEMENT_SEPARATOR, Token.Category.DEDENT):
    key = ';'
else:
    key = token.value(source)
===
String key = S token.category
   NUMERIC_LITERAL, STRING_LITERAL
      ‘(literal)’
   NAME
      ‘(name)’
   CONSTANT:
      ‘(constant)’
   STATEMENT_SEPARATOR, DEDENT
      ‘;’
   E
      token.value(source)


---
def find_ending_sq_bracket(str, i, start = 0):
    starti = i
    assert(str[i] == "[") # ]
    nesting_level = 0
    while True:
        ch = str[i]
        if ch == "[":
            nesting_level += 1
        elif ch == "]":
            nesting_level -= 1
            if nesting_level == 0:
                return i
        i += 1
        if i == len(str):
            exit_with_error('Unended comment started', start + starti)
===
F find_ending_sq_bracket(str, i, start = 0)
   A starti = i
   assert(str[i] == ‘[’)
   A nesting_level = 0
   L
      S str[i]
         ‘[’
            nesting_level++
         ‘]’
            I --nesting_level == 0
               return i
      i++
      I i == str.len
          exit_with_error(‘Unended comment started’, start + starti)
// balancing ]


str : str
str[:-1]
str[1:]
str[:1:]
str[1:2]
str[::2]
str[3:10:2]
str[3:10:]
===
String str
str[0.<(len)-1]
str[1..]
str[0.<1]
str[1.<2]
str[(0..).step(2)]
str[(3.<10).step(2)]
str[3.<10]


def to_str(self, indent):
    return super().to_str(indent)[:-1] + ' = ' + self.expression.to_str() + "\n"
===
F to_str(indent)
   R T.super.to_str(indent)[0.<(len)-1]‘ = ’(.expression.to_str())"\n"


def html_escapeq(str):
    return str.replace('&', '&amp;').replace('"', '&quot;')
link = 'http://...'
tag : str = '<a href="' + link + '"' # while type inference is not supported, type hint is necessary to convert from `+=` to `‘’=`
tag += html_escapeq()
===
F html_escapeq(str)
   R str.replace(‘&’, ‘&amp;’).replace(‘"’, ‘&quot;’)
A link = ‘http://...’
String tag = ‘<a href="’link‘"’
tag ‘’= html_escapeq()


str1 = '1'
str2 = '2'
# str = str1 + str2 # rarely needed, so write this:
str = str1 + '' + str2
===
A str1 = ‘1’
A str2 = ‘2’
A str = str1‘’str2


a : bool
b : bool
c : bool
if (a and b) or c:
    if a and (b or c):
        return
class ASTIf:
    pass
if (self.parent == None and isinstance(self.ast_parent, ASTIf)) or (self.parent != None and self.parent.symbol.id == 'if'):
    return
===
Bool a
Bool b
Bool c
I (a & b) | c
   I a & (b | c)
      R
T ASTIf
{
}
I (.parent == N & T(.ast_parent) >= ASTIf) | (.parent != N & .parent.symbol.id == ‘if’)
   R


l = lambda: None
l = lambda x: x[0]
l = lambda self: self # `self` here should not be replaced with ``
l = lambda x, y, reverse = False: y < x if reverse else x < y
===
A l = () -> N
l = x -> x[0]
l = self -> self
l = (x, y, reverse = 0B) -> I reverse {y < x} E x < y


class Object:
    pass

def f():
    pass
===
T Object
{
}

F f()
{
}


1 in 2
1 not in 2
===
1 C 2
1 !C 2


a : str
b : str
a is b
a is not b
===
String a
String b
&a == &b
&a != &b


source : str
def prev_char():
   return "\0"
tag = {'*':'b', '_':'u', '-':'s', '~':'i'}[prev_char()]
return {'None': 'N', 'False': '0B', 'True': '1B'}[self.token.value(source)]
python_types_to_11l = {'int':'Int', 'str':'String', 'List':'Array', 'Tuple':'Tuple'}
return self.children[0].to_str() + ' ' + {'and':'&', 'or':'|', 'in':'C'}.get(self.symbol.id, 'symbol-' + self.symbol.id) + ' ' + self.children[1].to_str()
===
String source
F prev_char()
   R "\0"
A tag = S prev_char() {‘*’ {‘b’}; ‘_’ {‘u’}; ‘-’ {‘s’}; ‘~’ {‘i’}}
R S .token.value(source) {‘None’ {‘N’}; ‘False’ {‘0B’}; ‘True’ {‘1B’}}
A python_types_to_11l = S {‘int’ {‘Int’}; ‘str’ {‘String’}; ‘List’ {‘Array’}; ‘Tuple’ {‘Tuple’}}
R .children[0].to_str()‘ ’(S .symbol.id {‘and’ {‘&’}; ‘or’ {‘|’}; ‘in’ {‘C’} E ‘symbol-’(.symbol.id)})‘ ’(.children[1].to_str())


x : bool
y : bool
ins : str
return not x == y
return not "\n" in ins
return not x
return not (x)
===
Bool x
Bool y
String ins
R !(x == y)
R !("\n" C ins)
R !x
R !(x)


def to_html(self, instr, outfile = None):
    i = 0
    writepos = 0
    def write_to_pos(pos, npos):
        nonlocal writepos
        outfile.write(instr[writepos:pos])
        writepos = npos
    def write_to_i(add_str, skip_chars = 1):
        def write():
            write_to_pos(i, i+skip_chars)
        write()
        outfile.write(add_str)
===
F to_html(instr, outfile = N)
   A i = 0
   A writepos = 0
   F write_to_pos(pos, npos)
      @outfile.write(@instr[@writepos.<pos])
      @writepos = npos
   F write_to_i(add_str, skip_chars = 1)
      F write()
         @@write_to_pos(@@i, @@i + @skip_chars)
      write()
      @outfile.write(add_str)


token = None
err_token = None
err_token if err_token != None else token
===
A token = N
A err_token = N
err_token ? token