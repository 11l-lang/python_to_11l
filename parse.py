from tokenizer import Token
from typing import List

class SymbolNode:
    token : Token
    #symbol : SymbolBase
    children : List['SymbolNode']# = []
    function_call : bool
    tuple : bool

    def __init__(self, token):
        self.token = token
        self.children = []

    def to_str(self):
        r = ''
        prev_token_end = self.children[0].token.start
        for c in self.children:
            r += source[prev_token_end:c.token.start]
            r += c.token.value(source)
            prev_token_end = c.token.end
        return r

class ASTNode:
    # children : List['ASTNode'] = [] # OMFG! This actually means static (common for all objects of type ASTNode) variable, not default value of member variable, that was unexpected to me as it contradicts C++11 behavior
    children : List['ASTNode']
    def __init__(self):
        self.children = []

class ASTProgram(ASTNode):
    def to_str(self):
        r = ''
        for c in self.children:
            r += c.to_str(0)
        return r

class ASTAssignment(ASTNode):
    dest : Token
    expression : SymbolNode

    def to_str(self, indent):
        return ' ' * (indent*3) + self.dest.value(source) + ' = ' + self.expression.to_str() + "\n"

class ASTFunctionDefinition(ASTNode):
    function_name : str
    function_arguments : List[str]# = []

    def __init__(self):
        super().__init__()
        self.function_arguments = []

    def to_str(self, indent):
        r = ' ' * (indent*3) + 'F ' + self.function_name + '(' + ", ".join(self.function_arguments) + ")\n"
        for c in self.children:
            r += c.to_str(indent+1)
        return r

class ASTReturn(ASTNode):
    expression : SymbolNode

    def to_str(self, indent):
        return ' ' * (indent*3) + 'R ' + self.expression.to_str() + "\n"

class ASTClassDefinition(ASTNode):
    pass

class Error(Exception):
    def __init__(self, message, pos):
        self.message = message
        self.pos = pos

def next_token():
    global token, tokeni, tokensn
    if token == None and tokeni != -1:
        raise Error('no more tokens', len(source))
    tokeni += 1
    if tokeni == len(tokens):
        token = None
        tokensn = None
    else:
        token = tokens[tokeni]
        tokensn = SymbolNode(token)
        #tokensn.symbol = symbol_table["(literal)" if token.is_literal() else "(name)" if token.category == Token.Category.NAME else token.value]

def peek_token(how_much = 1):
    return tokens[tokeni+how_much] if tokeni+how_much < len(tokens) else Token()

def expression():
    r = SymbolNode(token)
    while token != None and token.category not in (Token.Category.STATEMENT_SEPARATOR, Token.Category.DEDENT):
        r.children.append(tokensn)
        next_token()
    return r

def parse_internal(this_node) -> ASTNode:
    global token

    def new_scope_expected():
        if token.value(source) != ':':
            raise Error('expected `:`', token.start)
        next_token()
        assert(token.category == Token.Category.INDENT) # error message ‘expected an indented block’ is already generated by tokenizer, so there is just an assert
        next_token()

    while token != None:
        if token.category == Token.Category.KEYWORD:
            if token.value(source) == 'def':
                node = ASTFunctionDefinition()

                next_token()
                if token.category != Token.Category.NAME:
                    raise Error('expected function name', token.start)
                node.function_name = token.value(source)

                next_token()
                if token.value(source) != '(': # )
                    raise Error('expected `(` after function name', token.start) # )(

                next_token()
                while token.value(source) != ')':
                    if token.category != Token.Category.NAME:
                        raise Error('expected function\'s argument name', token.start)
                    node.function_arguments.append(token.value(source))
                    next_token() # ((
                    if token.value(source) not in ',)':
                        raise Error('expected `,` or `)` in function\'s arguments list', token.start)
                    if token.value(source) == ',':
                        next_token()

                next_token()
                new_scope_expected()

                parse_internal(node)

            elif token.value(source) == 'class':
                node = ASTClassDefinition()

            elif token.value(source) == 'return':
                next_token()
                node = ASTReturn()
                node.expression = expression()
                if token != None and token.category == Token.Category.STATEMENT_SEPARATOR:
                    next_token()

            else:
                raise Error('unrecognized statement started with keyword', token.start)

        elif token.category == Token.Category.NAME and peek_token().value(source) == '=':
            node = ASTAssignment()
            node.dest = token
            next_token()
            next_token()
            node.expression = expression()
            assert(token == None or token.category in (Token.Category.STATEMENT_SEPARATOR, Token.Category.DEDENT)) # [-replace with `raise Error` with meaningful error message after first precedent of triggering this assert-]
            if token != None and token.category == Token.Category.STATEMENT_SEPARATOR:
                next_token()

        elif token.category == Token.Category.DEDENT:
            return this_node

        else:
            raise Error('unrecognized statement', token.start)

        this_node.children.append(node)

    return this_node

def parse(tokens_, source_):
    global tokens, source, tokeni, token
    tokens = tokens_
    source = source_
    if len(tokens):
        tokeni = -1
        token = None
        next_token()
    p = ASTProgram()
    return parse_internal(p)
